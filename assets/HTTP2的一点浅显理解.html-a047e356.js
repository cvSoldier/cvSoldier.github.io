import{_ as e,W as t,X as o,a0 as a}from"./framework-c8ebc670.js";const c={},h=a('<blockquote><p>如有错误 非常欢迎指正</p></blockquote><h3 id="http2-0-比-1-x-快在哪儿" tabindex="-1"><a class="header-anchor" href="#http2-0-比-1-x-快在哪儿" aria-hidden="true">#</a> http2.0 比 1.x 快在哪儿</h3><p>2.0 性能增强的核心在于全新的二进制分帧层，它定义了如何封装http消息并在客户端和服务端之间传输。 1.x 中以换行符作为分隔符，2.0 将信息分割为更小的消息和帧，并进行二进制编码，再将这些独立的帧交错发送，再另一端重组，解决了1.x中存在的队首阻塞。（无端联想：重组时候是不是使用类似二叉堆的数据结构） （解决了http的队首阻塞，但TCP层的依然存在）</p><p>所有的通信都在一个TCP连接上完成。 1.x中如果客户端要发送多个并行的请求，必须使用多个TCP链接。直接导致TCP链接的效率低。</p><p>HTTP的每次通信都会携带header，在1.x中，这些数据都是通过纯文本形式发送的，通常会给每个请求增加500-800字节的负荷，如果算上cookie，负荷会更大。2.0会进行首部压缩。 首部压缩是指在客户端和服务器会使用“首部表”来跟踪之前发送的键值对，对于相同的数据，不再通过每次请求和响应携带。如图 <img src="https://segmentfault.com/img/bVcMZF7" alt="image"> (我傻了吧唧的一开始以为是gzip那种压缩) 在vue后台管理的工程中，封装axios使所有请求携带的token，同时也增大了所有请求，首部压缩完美解决。</p><h3 id="http2-0-优化方式有哪些改变" tabindex="-1"><a class="header-anchor" href="#http2-0-优化方式有哪些改变" aria-hidden="true">#</a> http2.0 优化方式有哪些改变</h3><p>首先不管什么协议，1降低网络延迟，2减少传输数据，这是基础。</p><p>在1.x的时代，把多个文件打包成一个以减少请求数量是一个很常用的方式，这种方式就像是使用了http管道，多个数据连在一起，消除了额外的网络延迟，实际就是把管道从传输层提升到了应用层。 这种方式的问题在于打包粒度，以雪碧图为例，工程里的小图打包成了一张，也就意味了如果其中一部分被替换了，用户就需要重新下载整张，在粒度上抠细节可以帮助网页实现递增式加载，但代价是代码的复杂程度（以及无辜的头发），只是权宜之计。在2.0中 就完全可以去掉不必要的打包了。 比如首屏渲染最开始只有一个 <code>home.js</code> ,然后做了骨架屏，拆成了 <code>骨架屏.js + home.js</code> ,想继续拆成 <code>骨架屏.js + 基础交互.js + home.js</code>，但是再拆可能因为额外的请求反而降低性能，在2.0中就不需要犹豫了。</p><p>在1.x中，场景是首页有一个单独的小图片，其他页面也有引用，为了首屏加载速度，不知道应该单独请求还是打包进雪碧图。2.0可以使用服务端推送来推送这些资源，直接推送进缓存，就像请求了一样，可以减少一次请求图片的消耗。不过缺点在于服务端推送是以缓存优先的，即缓存和推送同时存在时，使用缓存，而且浪费了这次推送的带宽。（可以通过检查是否携带cookie来判断是否首次访问，只在首次访问进行推送来解决）</p><p>在1.x中，可能性能受限于默认的每个来源六个链接而使用了域名分区，在2.0也可以去掉了。</p>',10),p=[h];function s(d,r){return t(),o("div",null,p)}const _=e(c,[["render",s],["__file","HTTP2的一点浅显理解.html.vue"]]);export{_ as default};
